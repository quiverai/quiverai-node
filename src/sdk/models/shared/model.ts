/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Modality, Modality$inboundSchema } from "./modality.js";
import { ModelPricing, ModelPricing$inboundSchema } from "./modelpricing.js";
import {
  SamplingParameter,
  SamplingParameter$inboundSchema,
} from "./samplingparameter.js";
import {
  SupportedOperation,
  SupportedOperation$inboundSchema,
} from "./supportedoperation.js";

/**
 * The object type, always "model" for model objects.
 */
export const ModelObject = {
  Model: "model",
} as const;
/**
 * The object type, always "model" for model objects.
 */
export type ModelObject = ClosedEnum<typeof ModelObject>;

/**
 * Describes a QuiverAI model offering that can be used with the API.
 *
 * @remarks
 * This schema is compatible with OpenAI SDK and OpenRouter.
 */
export type Model = {
  /**
   * Maximum context length in tokens.
   */
  contextLength?: number | undefined;
  /**
   * The Unix timestamp (in seconds) when the model was created.
   */
  created: number;
  /**
   * A description of the model and its capabilities.
   */
  description?: string | undefined;
  /**
   * The model identifier, which can be referenced in the API endpoints.
   */
  id: string;
  /**
   * Input modalities supported by the model.
   */
  inputModalities?: Array<Modality> | undefined;
  /**
   * Maximum output length in tokens.
   */
  maxOutputLength?: number | undefined;
  /**
   * Human-readable name of the model.
   */
  name?: string | undefined;
  /**
   * The object type, always "model" for model objects.
   */
  object: ModelObject;
  /**
   * Output modalities supported by the model.
   */
  outputModalities?: Array<Modality> | undefined;
  /**
   * The organization that owns the model.
   */
  ownedBy: string;
  /**
   * Pricing information for the model (per token, in USD as strings to avoid floating point issues).
   */
  pricing?: ModelPricing | undefined;
  /**
   * API operations supported by this model.
   */
  supportedOperations?: Array<SupportedOperation> | undefined;
  /**
   * Sampling parameters supported by the model.
   */
  supportedSamplingParameters?: Array<SamplingParameter> | undefined;
};

/** @internal */
export const ModelObject$inboundSchema: z.ZodNativeEnum<typeof ModelObject> = z
  .nativeEnum(ModelObject);

/** @internal */
export const Model$inboundSchema: z.ZodType<Model, z.ZodTypeDef, unknown> = z
  .object({
    context_length: z.number().int().optional(),
    created: z.number().int(),
    description: z.string().optional(),
    id: z.string(),
    input_modalities: z.array(Modality$inboundSchema).optional(),
    max_output_length: z.number().int().optional(),
    name: z.string().optional(),
    object: ModelObject$inboundSchema.default("model"),
    output_modalities: z.array(Modality$inboundSchema).optional(),
    owned_by: z.string().default("quiver"),
    pricing: ModelPricing$inboundSchema.optional(),
    supported_operations: z.array(SupportedOperation$inboundSchema).optional(),
    supported_sampling_parameters: z.array(SamplingParameter$inboundSchema)
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "context_length": "contextLength",
      "input_modalities": "inputModalities",
      "max_output_length": "maxOutputLength",
      "output_modalities": "outputModalities",
      "owned_by": "ownedBy",
      "supported_operations": "supportedOperations",
      "supported_sampling_parameters": "supportedSamplingParameters",
    });
  });

export function modelFromJSON(
  jsonString: string,
): SafeParseResult<Model, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model' from JSON`,
  );
}
