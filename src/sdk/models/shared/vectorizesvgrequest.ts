/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import {
  ImageInputReference,
  ImageInputReference$Outbound,
  ImageInputReference$outboundSchema,
} from "./imageinputreference.js";

export type VectorizeSVGRequest = {
  /**
   * If true, the image is automatically cropped to the subject before vectorization.
   *
   * @remarks
   * This can improve results for images with large amounts of empty space or
   * distracting backgrounds. We generally recommend users to crop their images
   * manually for best results.
   */
  autoCrop?: boolean | undefined;
  /**
   * Reference image input (URL or base64-encoded)
   */
  image: ImageInputReference;
  /**
   * Maximum tokens in the output
   */
  maxOutputTokens?: number | undefined;
  /**
   * The model to use for generation/editing
   */
  model: string;
  /**
   * Number of SVGs to generate
   */
  n?: number | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on
   *
   * @remarks
   * whether they appear in the text so far, increasing the model's likelihood
   * to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * If true, responses are streamed as Server-Sent Events
   */
  stream?: boolean | undefined;
  /**
   * Sampling temperature
   */
  temperature?: number | undefined;
  /**
   * Nucleus sampling parameter
   */
  topP?: number | undefined;
};

/** @internal */
export type VectorizeSVGRequest$Outbound = {
  auto_crop: boolean;
  image: ImageInputReference$Outbound;
  max_output_tokens?: number | undefined;
  model: string;
  n: number;
  presence_penalty: number | null;
  stream: boolean;
  temperature: number;
  top_p: number;
};

/** @internal */
export const VectorizeSVGRequest$outboundSchema: z.ZodType<
  VectorizeSVGRequest$Outbound,
  z.ZodTypeDef,
  VectorizeSVGRequest
> = z.object({
  autoCrop: z.boolean().default(false),
  image: ImageInputReference$outboundSchema,
  maxOutputTokens: z.number().int().optional(),
  model: z.string(),
  n: z.number().int().default(1),
  presencePenalty: z.nullable(z.number().default(0)),
  stream: z.boolean().default(false),
  temperature: z.number().default(1),
  topP: z.number().default(1),
}).transform((v) => {
  return remap$(v, {
    autoCrop: "auto_crop",
    maxOutputTokens: "max_output_tokens",
    presencePenalty: "presence_penalty",
    topP: "top_p",
  });
});

export function vectorizeSVGRequestToJSON(
  vectorizeSVGRequest: VectorizeSVGRequest,
): string {
  return JSON.stringify(
    VectorizeSVGRequest$outboundSchema.parse(vectorizeSVGRequest),
  );
}
