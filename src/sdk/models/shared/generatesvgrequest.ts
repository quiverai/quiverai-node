/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { AspectRatio, AspectRatio$outboundSchema } from "./aspectratio.js";
import {
  ImageInputReference,
  ImageInputReference$Outbound,
  ImageInputReference$outboundSchema,
} from "./imageinputreference.js";

export type GenerateSVGRequest = {
  /**
   * Aspect ratio constraint for the generated SVG, specified as "width:height".
   *
   * @remarks
   * - `1:1`: Square
   * - `4:3`: Standard/classic
   * - `3:4`: Portrait standard
   * - `16:9`: Landscape/widescreen
   * - `9:16`: Portrait/tall (mobile)
   * - `3:2`: Photo landscape
   * - `2:3`: Photo portrait
   * - `21:9`: Ultra-wide/cinematic
   */
  aspectRatio?: AspectRatio | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on
   *
   * @remarks
   * their existing frequency in the text so far, decreasing the model's
   * likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * Additional instructions for the model
   */
  instructions?: string | undefined;
  /**
   * Maximum tokens in the output
   */
  maxOutputTokens?: number | undefined;
  /**
   * The model to use for generation/editing
   */
  model: string;
  /**
   * Number of SVGs to generate
   */
  n?: number | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on
   *
   * @remarks
   * whether they appear in the text so far, increasing the model's likelihood
   * to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * The main text prompt describing the desired SVG
   */
  prompt: string;
  /**
   * Optional reference images to guide style/composition.
   *
   * @remarks
   * Maximum of 4 images.
   */
  references?: Array<ImageInputReference> | undefined;
  /**
   * This feature is in Beta.
   *
   * @remarks
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
   * Determinism is not guaranteed.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  seed?: number | null | undefined;
  /**
   * If true, responses are streamed as Server-Sent Events
   */
  stream?: boolean | undefined;
  /**
   * Sampling temperature
   */
  temperature?: number | undefined;
  /**
   * Nucleus sampling parameter
   */
  topP?: number | undefined;
};

/** @internal */
export type GenerateSVGRequest$Outbound = {
  aspect_ratio: string;
  frequency_penalty: number | null;
  instructions?: string | undefined;
  max_output_tokens?: number | undefined;
  model: string;
  n: number;
  presence_penalty: number | null;
  prompt: string;
  references?: Array<ImageInputReference$Outbound> | undefined;
  seed?: number | null | undefined;
  stream: boolean;
  temperature: number;
  top_p: number;
};

/** @internal */
export const GenerateSVGRequest$outboundSchema: z.ZodType<
  GenerateSVGRequest$Outbound,
  z.ZodTypeDef,
  GenerateSVGRequest
> = z.object({
  aspectRatio: AspectRatio$outboundSchema.default("1:1"),
  frequencyPenalty: z.nullable(z.number().default(0)),
  instructions: z.string().optional(),
  maxOutputTokens: z.number().int().optional(),
  model: z.string(),
  n: z.number().int().default(1),
  presencePenalty: z.nullable(z.number().default(0)),
  prompt: z.string(),
  references: z.array(ImageInputReference$outboundSchema).optional(),
  seed: z.nullable(z.number().int()).optional(),
  stream: z.boolean().default(false),
  temperature: z.number().default(1),
  topP: z.number().default(1),
}).transform((v) => {
  return remap$(v, {
    aspectRatio: "aspect_ratio",
    frequencyPenalty: "frequency_penalty",
    maxOutputTokens: "max_output_tokens",
    presencePenalty: "presence_penalty",
    topP: "top_p",
  });
});

export function generateSVGRequestToJSON(
  generateSVGRequest: GenerateSVGRequest,
): string {
  return JSON.stringify(
    GenerateSVGRequest$outboundSchema.parse(generateSVGRequest),
  );
}
